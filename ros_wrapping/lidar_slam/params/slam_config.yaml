#####################################
#  Real-time LiDAR SLAM parameters  #
#####################################

## Number of vertical lasers in LiDAR sensor (optional : if not given, it will be guessed from 1st frame)
# n_lasers: 16

## Mapping from ring id to laser id (optional, default : identity mapping)
# laser_id_mapping: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# SLAM will publish the TF slam_origin_frame -> slam_output_frame.
slam_origin_frame: "slam_init"   # Frame id of SLAM map origin.
# slam_output_frame: "velodyne"  # Frame id of the current SLAM pose (default : use frame_id of the input pointcloud).

# [Hz] Number of frames per second acquired by the LiDAR sensor (used to generate approximate point-wise timestamp)
lidar_frequency: 10.

# Verbosity level :
#  0) print errors, warnings or one time info
#  1) 0 + frame number, total frame processing time
#  2) 1 + extracted features, used keypoints, mapping variance, ego-motion and localization summary
#  3) 2 + sub-problems processing duration
#  4) 3 + ceres optimization summary
#  5) 4 + logging/maps memory usage
verbosity: 3

# Optional publishers
publish_features_maps:
  edges: true     # if true, edges features will be published to topic "edges_features"
  planars: true   # if true, planars features will be published to topic "planars_features"
  blobs: true     # if true, blobs features will be published to topic "blobs_features"

# Pointclouds saving to PCD files.
# To save keypoints maps, send command SlamCommand::SAVE_KEYPOINTS_MAPS to 'slam_command' topic.
pcd_saving:
  pcd_format: 2  # Save with given PCD file format : 0) ascii,  1) binary,  2) binary_compressed.

# Optionnal GPS-like pose publication or GPS position use to improve SLAM trajectory.
gps:

  gps_to_lidar_offset: [0., 0., 0., 0., 0., 0.]  # Pose (X, Y, Z, roll, pitch, yaw) of the LiDAR in GPS antenna coordinates (also help to perform better pose graph optimization or GPS/LiDAR calibration).

  # Optionnal publication of slam pose centered on GPS antenna instead of LiDAR sensor.
  output_gps_pose: false             # Outputs GPS antenna pose instead of LiDAR's.
  output_gps_pose_frame_id: "slam"  # Frame id of the GPS antenna pose computed by SLAM if output_gps_pose=true.

  # Optionnal GPS positions use to calibrate output SLAM pose to world coordinates and/or optimize SLAM trajectory.
  # If true, subscribes to gps topic 'gps_odom' (nav_msgs/Odometry), and logs GPS positions during 'slam/logging_timeout' seconds.
  # (WARNING Can be overridden in slam.launch with 'gps' arg).
  use_gps: false

  # Approximate GPS/SLAM calibration (enabled if use_gps=true)
  # Use GPS positions to approximately calibrate output SLAM pose to world coordinates. It will try to fit GPS
  # trajectory to SLAM trajectory with ICP to estimate the rigid transform that links 'gps_odom/header/frame_id' to
  # 'slam_origin_frame', and publish it to static TF server.
  # GPS/SLAM calibration can be triggered by sending SlamCommand::GPS_SLAM_CALIBRATION to 'slam_command' topic.
  calibration:
    no_roll: false                   # If true, impose calibration to have no roll rotation. DEBUG
    publish_icp_trajectories: false  # If true, publish ICP-aligned GPS and SLAM trajectories to 'icp_gps' and 'icp_slam' latched topics.

  # Pose Graph Optimization (PGO) (enabled if use_gps=true)
  # Use GPS positions and covariances to optimize computed SLAM trajectory and maps by correcting drift, and precisely
  # link SLAM pose to world coordinates.
  # PGO can be triggered by sending SlamCommand::GPS_SLAM_POSE_GRAPH_OPTIMIZATION to 'slam_command' topic.
  # WARNING : this process is not real-time.
  pose_graph_optimization:
    g2o_file_name: "/path/to/dir/pose_graph_optimization.g2o"  # Save pose graph to file (or do not save if null string or unset).
    publish_optimized_trajectory: false                        # If true, publish optimized SLAM trajectory to 'optim_slam_traj' latched topic.

# SLAM parameters (see Slam.h for description). Comment parameter to get default value.
slam:

  n_threads: 1         # Max number of threads to use for parallel processing
  fast_slam: true      # Use only planars keypoints used during EgoMotion for Mapping step, and not all.
  undistortion: false  # Undistort the frame to correct rolling shutter distortion. DEBUG

  # Optionnal logging of computed pose, mapping covariance and keypoints of each processed frame.
  #  - A value of 0. will disable logging.
  #  - A negative value will log all incoming data, without any timeout.
  #  - A positive value will keep only most recent data, forgetting all previous data older than LoggingTimeout seconds.
  # Logged data will be used for pose graph optimization or GPS antenna/LiDAR sensor calibration using GPS data.
  logging_timeout: 0.  # [s]

  # How to store pointclouds data during keypoints logging (if logging_timeout != 0):
  #  0) PCL pointcloud                    (in RAM,     no compression,      no overhead)
  #  1) Octree compressed binary data     (in RAM,    ~5x compression,   ~3 ms overhead)
  #  2) Ascii format PCD file             (on disk, ~0.6x compression,   ~5 ms overhead)
  #  3) Binary format PCD file            (on disk, ~1.3x compression, ~0.3 ms overhead)
  #  4) Binary compressed format PCD file (on disk, ~1.5x compression, ~0.8 ms overhead)
  logging_storage: 0

  max_distance_for_ICP_matching: 20.            # [m] Max distance allowed between two keypoints during ICP matching.

  # ICP and LM parameters for Ego-Motion step
  ego_motion_ICP_max_iter: 4                     # Max number of iterations of ICP matching.
  ego_motion_LM_max_iter: 15                     # Max number of iteration in the ego motion LM optimization step.
  ego_motion_line_distance_nbr_neighbors: 8      # Number of nearest neighbors to look for in previous frame (all scan lines considered) to build line model.
  ego_motion_minimum_line_neighbor_rejection: 3  # Min number of valid nearest neighbors (max 1 per scan line) to keep neighborhood to build line model.
  ego_motion_line_distance_factor: 5.            # PCA eigenvalues ratio to consider a neighborhood fits a line model (V2 > factor * V1).
  ego_motion_plane_distance_nbr_neighbors: 5     # Number of nearest neighbors to look for in previous frame to build plane model.
  ego_motion_plane_distance_factor1: 35.         # PCA eigenvalues ratio to consider a neighborhood fits a plane model :
  ego_motion_plane_distance_factor2: 8.          #   V2 < factor2 * V1  and  V1 > factor1 * V0
  ego_motion_max_line_distance: 0.2              # [m] Max distance to line model allowed to keep neighborhood.
  ego_motion_max_plane_distance: 0.2             # [m] Max distance to plane model allowed to keep neighborhood.
  ego_motion_init_loss_scale: 2.                 # initial arctan loss scale factor to modify saturation (L(s) = scale * arctan(s/scale))
  ego_motion_final_loss_scale: 0.2               # final arctan loss scale factor to modify saturation (L(s) = scale * arctan(s/scale))

  # ICP and LM parameters for Mapping step
  mapping_ICP_max_iter: 3                     # Max number of iterations of ICP matching.
  mapping_LM_max_iter: 15                     # Max number of iteration in the ego motion LM optimization step.
  mapping_line_distance_nbr_neighbors: 10     # Number of nearest neighbors to look for in map to build line model.
  mapping_minimum_line_neighbor_rejection: 4  # Min number of valid nearest neighbors (close to line model) to keep neighborhood to conisder line model.
  mapping_line_distance_factor: 5.            # PCA eigenvalues ratio to consider a neighborhood fits a line model (V2 > factor * V1).
  mapping_plane_distance_nbr_neighbors: 5     # Number of nearest neighbors to look for in map to build plane model.
  mapping_plane_distance_factor1: 35.         # PCA eigenvalues ratio to consider a neighborhood fits a plane model :
  mapping_plane_distance_factor2: 8.          #   V2 < factor2 * V1  and  V1 > factor1 * V0
  mapping_max_line_distance: 0.2              # [m] Max distance to line model allowed to keep neighborhood.
  mapping_max_plane_distance: 0.2             # [m] Max distance to plane model allowed to keep neighborhood.
  mapping_line_max_dist_inlier: 0.2           # [m] Max distance of current point to tested line model so that it votes for the validity of this model
  mapping_init_loss_scale: 0.7                # initial arctan loss scale factor to modify saturation (L(s) = scale * arctan(s/scale))
  mapping_final_loss_scale: 0.05              # final arctan loss scale factor to modify saturation (L(s) = scale * arctan(s/scale))

  voxel_grid_leaf_size_edges: 0.45   # [m] Resolution used to downsample the edges map with a VoxelGrid filter.
  voxel_grid_leaf_size_planes: 0.6   # [m] Resolution used to downsample the planes map with a VoxelGrid filter.
  voxel_grid_leaf_size_blobs: 0.12   # [m] Resolution used to downsample the blobs map with a VoxelGrid filter.
  voxel_grid_size: 50                # [voxels] Size of the voxel grid used to store keypoints maps : n*n*n voxels.
  voxel_grid_resolution: 10.         # [m/voxel] Resolution of a voxel.